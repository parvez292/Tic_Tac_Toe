<!doctype html>
<html lang="en">
<head>
  <link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#ff0000"/>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, viewport-fit=cover, initial-scale=1, user-scalable=no" />
<title>Neon Tic Tac Toe — Robot Edition</title>
<style>
  :root{
    --bg: #05060c;
    --bg2:#0a1021;
    --outline: rgba(255,255,255,0.14);
    --accent:#9b4dff;
    --accent2:#00f5ff;
    --x: #ff6fa3;
    --o: #76f7ff;
    --win: #b7ff6a;
    --text: #eaf2ff;
    --muted:#9aadc8;
    --shadow: 0 10px 40px rgba(0,0,0,0.45);
    --radius: 18px;
    --board-max: 520px;
    --edge-gap: clamp(10px, 3.5vw, 18px); /* controls left/right breathing room on phones */
  }

  *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
  html,body{ height:100% }
  body{
    margin:0;
    font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;
    color:var(--text);
    background:
      radial-gradient(1200px 600px at 10% -10%, #1a2245 0%, transparent 60%),
      radial-gradient(900px 900px at 110% 10%, #141c3a 0%, transparent 60%),
      linear-gradient(180deg, var(--bg), var(--bg2));
    overflow-x:hidden;
  }

  /* Animated background layers */
  .bg-anim{ position:fixed; inset:0; z-index:0; pointer-events:none; }
  .bg-anim .orbs::before,
  .bg-anim .orbs::after{
    content:""; position:absolute; border-radius:50%;
    width:60vmax; height:60vmax; filter: blur(60px) saturate(120%);
    mix-blend-mode:screen; opacity:.33;
  }
  .bg-anim .orbs::before{
    background: radial-gradient(circle at 30% 30%, rgba(155,77,255,.9), transparent 60%);
    top:-20vmax; left:-15vmax; animation: float1 16s ease-in-out infinite alternate;
  }
  .bg-anim .orbs::after{
    background: radial-gradient(circle at 70% 70%, rgba(0,245,255,.9), transparent 60%);
    bottom:-25vmax; right:-20vmax; animation: float2 18s ease-in-out infinite alternate;
    opacity:.26;
  }
  @keyframes float1{ from{transform:translate(0,0)} to{transform:translate(3vmax,2vmax)} }
  @keyframes float2{ from{transform:translate(0,0)} to{transform:translate(-3vmax,-2vmax)} }

  .bg-anim .neon-grid{
    position:absolute; inset:0; opacity:.18; mix-blend-mode:screen;
    background:
      repeating-linear-gradient(0deg, rgba(0,245,255,.12) 0 2px, transparent 2px 60px),
      repeating-linear-gradient(90deg, rgba(155,77,255,.12) 0 2px, transparent 2px 60px);
    animation: gridShift 28s linear infinite;
    filter: drop-shadow(0 0 12px rgba(0,245,255,.3));
  }
  @keyframes gridShift{
    0%{ background-position: 0 0, 0 0 }
    100%{ background-position: 120px 0, 0 120px }
  }
  .bg-anim .aurora{
    position:absolute; inset:-10%;
    background:
      radial-gradient(60vmax 60vmax at 10% 20%, rgba(155,77,255,.18), transparent 60%),
      radial-gradient(60vmax 60vmax at 90% 80%, rgba(0,245,255,.14), transparent 60%),
      radial-gradient(40vmax 40vmax at 40% 90%, rgba(255,255,255,.06), transparent 60%);
    animation: auroraShift 18s ease-in-out infinite alternate;
    mix-blend-mode:screen;
  }
  @keyframes auroraShift{
    0%{ transform: translateX(0) translateY(0) rotate(0deg) }
    100%{ transform: translateX(2%) translateY(-1%) rotate(2deg) }
  }

  /* Technology effect canvas */
  .tech-canvas{
    position:fixed; inset:0; z-index:0;
    mix-blend-mode:screen; opacity:.28; pointer-events:none;
    filter: saturate(120%) drop-shadow(0 0 12px rgba(0,245,255,.25));
  }

  .app{
    position:relative; z-index:1;
    max-width: 980px;
    width: 100%;
    margin:0 auto;
    padding: 20px;
    padding-left: max(12px, env(safe-area-inset-left));
    padding-right: max(12px, env(safe-area-inset-right));
    padding-top: calc(16px + env(safe-area-inset-top));
    padding-bottom: calc(16px + env(safe-area-inset-bottom));
  }

  .header{
    display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom:18px;
    flex-wrap:wrap;
  }
  .title{
    margin:0;
    font-size: clamp(22px, 5vw, 36px);
    letter-spacing: 0.6px;
    background: linear-gradient(90deg, #ffffff, #d4ecff 20%, #a38cff 45%, #76f7ff 70%, #ffffff 100%);
    -webkit-background-clip:text; background-clip:text; color:transparent;
    text-shadow: 0 10px 40px rgba(0,0,0,.35);
    background-size: 200% auto; animation: gradientShift 8s linear infinite;
  }
  @keyframes gradientShift{
    0%{background-position: 0% 50%}
    100%{background-position: 200% 50%}
  }
  .badges{display:flex; gap:8px; flex-wrap:wrap}
  .badge{
    font-size:12px; letter-spacing:.2px; padding:6px 10px; border-radius:999px;
    background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.05));
    border:1px solid rgba(255,255,255,.18);
    box-shadow: var(--shadow), 0 0 22px rgba(124,77,255,.25) inset;
    user-select:none;
  }
  .badge.neon{
    border-color: rgba(124,77,255,.5);
    box-shadow: 0 0 24px rgba(124,77,255,.45), inset 0 0 20px rgba(124,77,255,.2), var(--shadow);
  }

  .shell{
    background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
    border: 1px solid var(--outline);
    border-radius: calc(var(--radius) + 6px);
    padding: 14px;
    box-shadow: var(--shadow);
    backdrop-filter: blur(10px);
    position:relative;
    overflow:hidden;
  }
  .shell::before{
    content:"";
    position:absolute; inset:-2px;
    border-radius: inherit;
    padding:2px; pointer-events:none;
    background: conic-gradient(from 0deg, rgba(155,77,255,.0), rgba(155,77,255,.6), rgba(0,245,255,.6), rgba(155,77,255,.0));
    -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
            mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
    -webkit-mask-composite: xor; mask-composite: exclude;
    animation: spin 8s linear infinite;
    opacity:.35;
  }
  @keyframes spin{ to{ transform: rotate(360deg) } }

  .topbar{
    display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;
    margin-bottom: 12px;
  }

  .btn{
    position:relative; appearance:none; border:none; cursor:pointer; touch-action: manipulation;
    color:var(--text); font-weight:700; font-size: 16px;
    padding:12px 16px; border-radius: 12px; min-height:44px;
    border:1px solid rgba(255,255,255,.18);
    background:
      radial-gradient(120% 120% at 30% 25%, rgba(255,255,255,.15), rgba(255,255,255,.06) 60%, rgba(255,255,255,.03) 100%),
      linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.05));
    transition: transform .08s ease, box-shadow .25s ease, background .2s ease, border-color .2s ease, opacity .2s ease;
    box-shadow: 0 2px 0 rgba(255,255,255,.05), 0 10px 30px rgba(0,0,0,.28), 0 0 0 0 rgba(155,77,255,.5);
  }
  .btn:hover{
    transform: translateY(-1px);
    box-shadow: 0 0 0 2px rgba(155,77,255,.35), 0 0 24px rgba(155,77,255,.35), 0 10px 30px rgba(0,0,0,.28);
  }
  .btn:active{ transform: translateY(0) }
  .btn:disabled{ opacity:.55; cursor:not-allowed }
  .btn.primary{
    background: linear-gradient(180deg, rgba(155,77,255,.55), rgba(155,77,255,.25));
    border-color: rgba(155,77,255,.65);
    box-shadow: 0 0 24px rgba(155,77,255,.45), inset 0 0 18px rgba(255,255,255,.18);
  }
  .btn .icon{ width:18px; height:18px; opacity:.9; vertical-align:middle; }

  .inline-row{ display:flex; align-items:center; gap:12px; flex-wrap:wrap }

  .toggle{
    display:flex; align-items:center; gap:10px; user-select:none;
    padding:8px 10px; border-radius:999px;
    border:1px solid rgba(255,255,255,.18);
    background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.05));
    box-shadow: inset 0 0 0 1px rgba(0,0,0,.2), 0 8px 26px rgba(0,0,0,.2);
  }
  .switch{
    position:relative; width:56px; height:30px; border-radius:999px;
    background: rgba(255,255,255,.10);
    border:1px solid rgba(255,255,255,.18);
    box-shadow: inset 0 0 0 1px rgba(0,0,0,.2);
    cursor:pointer; transition: background .2s ease, border-color .2s ease;
  }
  .switch input{ display:none }
  .knob{
    position:absolute; top:2px; left:2px; width:26px; height:26px; border-radius:50%;
    background: linear-gradient(180deg, #ffffff, #cfd5ff);
    box-shadow: 0 6px 14px rgba(0,0,0,.25);
    transition: transform .22s cubic-bezier(.2,.8,.2,1), background .2s ease, box-shadow .2s ease;
  }
  .switch input:checked + .knob{
    transform: translateX(24px);
    background: linear-gradient(180deg, #8cf7ff, #74d5ff);
    box-shadow: 0 0 20px rgba(0,245,255,.6), 0 6px 14px rgba(0,0,0,.25);
  }

  /* Difficulty segmented control */
  .seg{
    display:inline-flex; border-radius: 999px; overflow:hidden; user-select:none;
    border:1px solid rgba(255,255,255,.18);
    background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.06));
    box-shadow: inset 0 0 0 1px rgba(0,0,0,.15), 0 8px 26px rgba(0,0,0,.2);
  }
  .seg input{ display:none }
  .seg label{
    padding:10px 14px; font-weight:700; font-size:14px; cursor:pointer; color:#cfe4ff;
    min-width:78px; text-align:center; letter-spacing:.2px;
  }
  .seg input:checked + label{
    color:#0b1022;
    background: linear-gradient(180deg, rgba(155,77,255,.9), rgba(0,245,255,.9));
    box-shadow: 0 0 22px rgba(155,77,255,.4), inset 0 0 14px rgba(255,255,255,.3);
  }

  .status{
    padding:12px 14px;
    border-radius: 12px;
    border:1px solid rgba(255,255,255,.18);
    background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
    color:var(--text);
    margin-bottom: 12px;
    display:flex; align-items:center; gap:12px; min-height:48px;
  }
  .dot{
    width:12px; height:12px; border-radius:50%;
    background: var(--muted);
    box-shadow: 0 0 18px currentColor, 0 0 40px currentColor;
    animation: pulse 2.2s ease-in-out infinite;
  }
  .dot.x{ background: var(--x) }
  .dot.o{ background: var(--o) }
  .dot.win{ background: var(--win) }
  @keyframes pulse{
    0%,100% { transform: scale(1); filter: brightness(1) }
    50% { transform: scale(1.15); filter: brightness(1.3) }
  }
  .thinking{ display:inline-flex; align-items:center; gap:10px; color:#b8c6ff; }
  .spinner{
    width:14px; height:14px; border-radius:50%;
    background: conic-gradient(from 0deg, rgba(155,77,255,.0), rgba(155,77,255,.9), rgba(0,245,255,.9), rgba(155,77,255,.0));
    -webkit-mask: radial-gradient(circle, transparent 53%, black 54%);
            mask: radial-gradient(circle, transparent 53%, black 54%);
    animation: spin 1s linear infinite;
    filter: drop-shadow(0 0 6px rgba(0,245,255,.7));
  }

  .board-wrap{
    position:relative;
    padding: clamp(8px, 3vw, 14px);
    background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    border: 1px solid var(--outline);
    border-radius: var(--radius);
    overflow:hidden;
    overscroll-behavior: contain;
  }
  .board-wrap::after{
    content:"";
    position:absolute; inset:0;
    background: linear-gradient(120deg, transparent 0%, rgba(255,255,255,.05) 10%, transparent 20%);
    transform: translateX(-100%);
    animation: sheen 6s ease-in-out infinite;
    pointer-events:none;
  }
  @keyframes sheen{
    0%,10%{ transform: translateX(-120%) }
    45%{ transform: translateX(120%) }
    100%{ transform: translateX(120%) }
  }

  /* WIDTH FIX: board auto-fits viewport on mobile with safe areas */
  .board{
    display:grid;
    grid-template-columns: repeat(3, 1fr);
    gap: clamp(8px, 2.8vw, 14px);
    width: min(
      100%,
      var(--board-max),
      calc(100vw - env(safe-area-inset-left) - env(safe-area-inset-right) - var(--edge-gap)*2)
    );
    margin-left: auto;
    margin-right: auto;
    aspect-ratio: 1 / 1; /* modern browsers keep perfect square */
    position:relative;
    animation: boardPop .4s cubic-bezier(.2,.8,.2,1);
  }
  @keyframes boardPop{
    from{ transform: scale(.97); opacity: .0 }
    to{ transform: scale(1); opacity: 1 }
  }

  .cell{
    position:relative;
    border:1px solid rgba(255,255,255,.15);
    background:
      radial-gradient(130% 130% at 30% 25%, rgba(255,255,255,.14), rgba(255,255,255,.05) 60%, rgba(255,255,255,.03) 100%),
      linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
    border-radius: 16px;
    cursor:pointer; touch-action: manipulation;
    overflow:hidden;
    padding:0;
    outline:none;
    transition: transform .06s ease, border-color .2s ease, background .2s ease, box-shadow .2s ease, filter .2s ease;
    aspect-ratio: 1/1; /* ensures perfect squares even if aspect-ratio on grid fails */
  }
  .cell:hover{
    transform: translateY(-1px);
    border-color: rgba(0,245,255,.5);
    box-shadow: 0 0 0 2px rgba(0,245,255,.25), 0 0 26px rgba(0,245,255,.3), inset 0 0 24px rgba(0,245,255,.12);
    filter: saturate(115%);
  }
  .cell:active{ transform: translateY(0) }
  .cell:focus-visible{ box-shadow: 0 0 0 3px rgba(155,77,255,.55), 0 0 28px rgba(155,77,255,.45) }

  .cell::after{
    content:"";
    position:absolute; inset:0;
    background: radial-gradient(140% 140% at 20% 20%, rgba(155,77,255,.10), transparent 45%);
    opacity:.9; pointer-events:none;
    transition: opacity .2s ease;
  }
  .cell:hover::after{ opacity:1 }

  .glyph{
    position:absolute; inset: 12% 12%;
    display:block;
    filter: drop-shadow(0 8px 24px rgba(0,0,0,.4));
    transform: scale(.85);
    animation: pop .22s cubic-bezier(.2,.8,.2,1);
  }
  @keyframes pop{
    from{ transform: scale(.65); opacity:.0 }
    to{ transform: scale(.85); opacity:1 }
  }

  .glyph.x::before, .glyph.x::after{
    content:""; position:absolute; top:50%; left:50%;
    width: 78%; height: 15%;
    border-radius: 8px;
    transform-origin: center;
    background: linear-gradient(90deg, #ff9bc6, #ff5fa7);
    box-shadow: 0 0 22px rgba(255,95,167,.5), inset 0 0 12px rgba(255,255,255,.35);
  }
  .glyph.x::before{ transform: translate(-50%, -50%) rotate(45deg) }
  .glyph.x::after{ transform: translate(-50%, -50%) rotate(-45deg) }

  .glyph.o{
    border-radius:50%;
    background: conic-gradient(from 0deg, #76f7ff, #7aa5ff, #76f7ff);
    -webkit-mask: radial-gradient(circle, transparent 54%, black 56%);
            mask: radial-gradient(circle, transparent 54%, black 56%);
    box-shadow: 0 0 22px rgba(0,245,255,.45), inset 0 0 12px rgba(255,255,255,.4);
  }

  .cell.win{
    box-shadow: 0 0 0 2px rgba(183,255,106,.9), 0 0 32px rgba(183,255,106,.5), inset 0 0 34px rgba(183,255,106,.17);
    border-color: rgba(183,255,106,.95);
    animation: winPulse 1.2s ease-in-out infinite;
  }
  @keyframes winPulse{
    0%,100% { filter: brightness(1) saturate(1) }
    50% { filter: brightness(1.25) saturate(1.2) }
  }
  .cell.win .glyph.x::before, .cell.win .glyph.x::after{
    background: linear-gradient(90deg, #dcffb7, #b7ff6a);
    box-shadow: 0 0 26px rgba(183,255,106,.65), inset 0 0 14px rgba(255,255,255,.55);
  }
  .cell.win .glyph.o{
    background: conic-gradient(#dcffb7, #b7ff6a, #dcffb7);
    box-shadow: 0 0 26px rgba(183,255,106,.65), inset 0 0 14px rgba(255,255,255,.55);
  }

  .footer{
    margin-top: 12px;
    color: var(--muted);
    font-size: 12px;
    text-align:center;
    opacity:.9;
  }
  .kbd{
    display:inline-block; padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.2);
    background: rgba(255,255,255,.06); color:#e9f0ff; margin:0 2px;
  }

  /* Mobile tightening for true edge fit */
  @media (max-width: 540px){
    .app{ padding-left: env(safe-area-inset-left); padding-right: env(safe-area-inset-right); }
    .shell{ padding: 12px; border-left-width: 0; border-right-width: 0; border-radius: 0; }
    .board-wrap{ padding: 0; border-left-width: 0; border-right-width: 0; border-radius: 0; }
    .board{
      /* exact fit minus small breathing room and safe areas */
      width: calc(100vw - env(safe-area-inset-left) - env(safe-area-inset-right) - var(--edge-gap)*2);
      margin-left: var(--edge-gap);
      margin-right: var(--edge-gap);
      gap: clamp(6px, 2.5vw, 12px);
    }
  }

  /* Respect reduced motion */
  @media (prefers-reduced-motion: reduce){
    *{ animation: none !important; transition: none !important }
  }
</style>
</head>
<body>
  <!-- Animated background -->
  <div class="bg-anim" aria-hidden="true">
    <canvas class="tech-canvas" id="techCanvas"></canvas>
    <div class="orbs"></div>
    <div class="neon-grid"></div>
    <div class="aurora"></div>
  </div>

  <div class="app">
    <div class="header">
      <h1 class="title">NS Tic‑Tac‑Toe</h1>
      <div class="badges">
        <span class="badge neon">Neon</span>
        <span class="badge">Premium Gradients</span>
        <span class="badge">Animated</span>
        <span class="badge">Dev: Parvez</span>
      </div>
    </div>

    <div class="shell">
      <div class="topbar">
        <div class="inline-row">
          <div class="toggle" title="Play vs Robot">
            <span style="opacity:.9">VS Robot</span>
            <label class="switch" aria-label="Toggle Robot opponent">
              <input type="checkbox" id="robotToggle" checked>
              <span class="knob"></span>
            </label>
          </div>

          <!-- Difficulty segmented control -->
          <div class="seg" role="radiogroup" aria-label="Robot difficulty">
            <input type="radio" name="level" id="lvl-easy" value="easy">
            <label for="lvl-easy" aria-label="Easy">Easy</label>
            <input type="radio" name="level" id="lvl-normal" value="normal" checked>
            <label for="lvl-normal" aria-label="Normal">Normal</label>
            <input type="radio" name="level" id="lvl-hard" value="hard">
            <label for="lvl-hard" aria-label="Hard">Hard</label>
          </div>
        </div>

        <div>
          <button id="undoBtn" class="btn" disabled>
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true"><path stroke-width="2" d="M9 10l-5 5 5 5"/><path stroke-width="2" d="M4 15h9a5 5 0 1 0 0-10h-1"/></svg>
            Undo
          </button>
          <button id="restartBtn" class="btn primary">
            <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true"><path stroke-width="2" d="M4.05 11a8 8 0 1 1 1.91 5.13"/><path stroke-width="2" d="M4 4v7h7"/></svg>
            Restart
          </button>
        </div>
      </div>

      <div id="status" class="status" aria-live="polite">
        <span class="dot x"></span>
        X’s turn — you’re X. Robot is O.
      </div>

      <div class="board-wrap">
        <div id="board" class="board" role="grid" aria-label="Tic-Tac-Toe Board">
          <button class="cell" data-index="0" role="gridcell" aria-label="Cell 1"></button>
          <button class="cell" data-index="1" role="gridcell" aria-label="Cell 2"></button>
          <button class="cell" data-index="2" role="gridcell" aria-label="Cell 3"></button>
          <button class="cell" data-index="3" role="gridcell" aria-label="Cell 4"></button>
          <button class="cell" data-index="4" role="gridcell" aria-label="Cell 5"></button>
          <button class="cell" data-index="5" role="gridcell" aria-label="Cell 6"></button>
          <button class="cell" data-index="6" role="gridcell" aria-label="Cell 7"></button>
          <button class="cell" data-index="7" role="gridcell" aria-label="Cell 8"></button>
          <button class="cell" data-index="8" role="gridcell" aria-label="Cell 9"></button>
        </div>
      </div>
    </div>

    <div class="footer">
      Tips: Use arrow keys + Enter. <span class="kbd">U</span> Undo, <span class="kbd">R</span> Restart, <span class="kbd">C</span> Toggle Robot.<br/>
      Developed by Parvez ✨
    </div>
  </div>

<script>
(() => {
  // ===== Game Logic =====
  const boardEl = document.getElementById('board');
  const cells = Array.from(boardEl.querySelectorAll('.cell'));
  const statusEl = document.getElementById('status');
  const undoBtn = document.getElementById('undoBtn');
  const restartBtn = document.getElementById('restartBtn');
  const robotToggle = document.getElementById('robotToggle');
  const levelRadios = Array.from(document.querySelectorAll('input[name="level"]'));

  const WIN_LINES = [
    [0,1,2],[3,4,5],[6,7,8],
    [0,3,6],[1,4,7],[2,5,8],
    [0,4,8],[2,4,6]
  ];

  const state = {
    board: Array(9).fill(null),
    xIsNext: true,
    winner: null,
    winLine: null,
    isDraw: false,
    vsRobot: true,
    robotPlays: 'O',
    difficulty: 'normal', // easy | normal | hard
    history: [],
    aiTimer: null,
    locked: false
  };

  const clone = (b) => b.slice();
  const other = (p) => (p === 'X' ? 'O' : 'X');
  const canVibrate = 'vibrate' in navigator;
  const vibe = (pattern) => { if (canVibrate) navigator.vibrate(pattern); };

  function computeWinner(b){
    for (const line of WIN_LINES){
      const [a,bx,c] = line;
      if (b[a] && b[a] === b[bx] && b[a] === b[c]) {
        return { winner: b[a], line };
      }
    }
    return null;
  }
  function getEmptyIndices(b){
    const out = [];
    for (let i=0;i<9;i++) if (!b[i]) out.push(i);
    return out;
  }
  function findWinningMove(b, player){
    const empties = getEmptyIndices(b);
    for (const idx of empties){
      b[idx] = player;
      const win = computeWinner(b);
      b[idx] = null;
      if (win && win.winner === player) return idx;
    }
    return null;
  }
  function heuristicMove(b){
    const empties = getEmptyIndices(b);
    const order = [4,0,2,6,8,1,3,5,7]; // center -> corners -> edges
    for (const idx of order){
      if (empties.includes(idx)) return idx;
    }
    return empties[Math.floor(Math.random()*empties.length)];
  }

  const mmCache = new Map();
  function minimax(board, player, depth, aiMark){
    const key = board.join('') + '|' + player;
    const win = computeWinner(board);
    if (win) return { score: win.winner === aiMark ? 10 - depth : depth - 10 };
    const empties = getEmptyIndices(board);
    if (!empties.length) return { score: 0 };

    const isMax = player === aiMark;
    let bestScore = isMax ? -Infinity : +Infinity;
    let bestMove = null;

    const cached = mmCache.get(key);
    if (cached && cached.depth <= depth) return cached.res;

    for (const idx of empties){
      board[idx] = player;
      const res = minimax(board, other(player), depth+1, aiMark);
      board[idx] = null;

      if (isMax) {
        if (res.score > bestScore){ bestScore = res.score; bestMove = idx; }
      } else {
        if (res.score < bestScore){ bestScore = res.score; bestMove = idx; }
      }
    }
    const out = { score: bestScore, move: bestMove };
    mmCache.set(key, { res: out, depth });
    return out;
  }
  function bestMove(board, aiMark){
    const { move } = minimax(board.slice(), aiMark, 0, aiMark);
    const empties = getEmptyIndices(board);
    return move !== null && move !== undefined ? move : empties[Math.floor(Math.random()*empties.length)];
  }

  function chooseRobotMove(board, aiMark){
    const opp = other(aiMark);
    const empties = getEmptyIndices(board);

    const winNow = findWinningMove(board, aiMark);
    if (winNow !== null) return winNow;

    const block = findWinningMove(board, opp);
    if (block !== null){
      if (state.difficulty === 'hard') return block;
      if (state.difficulty === 'normal' && Math.random() < 0.9) return block;
      if (state.difficulty === 'easy' && Math.random() < 0.5) return block;
    }

    if (state.difficulty === 'easy'){
      if (Math.random() < 0.2) return bestMove(board, aiMark);
      return empties[Math.floor(Math.random()*empties.length)];
    }

    if (state.difficulty === 'normal'){
      if (Math.random() < 0.7) return bestMove(board, aiMark);
      return heuristicMove(board);
    }

    // hard: gets tougher as the board fills (more and more difficult)
    const filled = 9 - empties.length;
    const ramp = Math.min(1, Math.max(0, 0.85 + 0.15*(filled/9))); // 85% -> 100%
    if (Math.random() < ramp) return bestMove(board, aiMark);
    return heuristicMove(board);
  }

  function snapshot(){
    state.history.push({
      board: clone(state.board),
      xIsNext: state.xIsNext,
      winner: state.winner,
      winLine: state.winLine,
      isDraw: state.isDraw
    });
    updateControls();
  }
  function popHistory(n=1){
    for (let i=0;i<n;i++){
      if (state.history.length > 1) state.history.pop();
    }
    const snap = state.history[state.history.length - 1];
    setFromSnapshot(snap);
    render();
  }
  function setFromSnapshot(s){
    state.board = clone(s.board);
    state.xIsNext = s.xIsNext;
    state.winner = s.winner;
    state.winLine = s.winLine;
    state.isDraw = s.isDraw;
  }

  function render(){
    for (let i=0;i<9;i++){
      const cell = cells[i];
      const val = state.board[i];
      cell.classList.remove('win');
      cell.innerHTML = '';
      cell.disabled = !!state.winner || !!val || state.locked;

      if (val === 'X'){
        cell.innerHTML = '<div class="glyph x" aria-hidden="true"></div>';
      } else if (val === 'O'){
        cell.innerHTML = '<div class="glyph o" aria-hidden="true"></div>';
      }
    }

    if (state.winLine){
      for (const idx of state.winLine) cells[idx].classList.add('win');
    }

    statusEl.innerHTML = '';
    const dotEl = document.createElement('span');
    dotEl.className = 'dot ' + (state.winner ? 'win' : (state.xIsNext ? 'x' : 'o'));
    statusEl.appendChild(dotEl);

    if (state.winner){
      statusEl.appendChild(document.createTextNode(`${state.winner} wins!`));
    } else if (state.isDraw){
      statusEl.appendChild(document.createTextNode(`Draw game.`));
    } else if (state.locked && state.vsRobot){
      const wrap = document.createElement('span');
      wrap.className = 'thinking';
      wrap.innerHTML = '<span class="spinner" aria-hidden="true"></span> Robot is thinking…';
      statusEl.appendChild(wrap);
    } else {
      const youAre = state.vsRobot ? ` — you’re ${state.robotPlays === 'X' ? 'O' : 'X'}. Robot is ${state.robotPlays}.` : ' — 2 players';
      statusEl.appendChild(document.createTextNode(`${state.xIsNext ? 'X' : 'O'}’s turn${youAre}`));
    }

    updateControls();
  }

  function updateControls(){
    undoBtn.disabled = state.history.length <= 1;
    cells.forEach(c => { c.disabled = state.locked || !!state.winner || !!c.querySelector('.glyph'); });
  }

  function startNewGame(keepRobotSide=true){
    clearAITimer();
    state.board = Array(9).fill(null);
    state.xIsNext = true;
    state.winner = null;
    state.winLine = null;
    state.isDraw = false;
    state.history = [];
    state.locked = false;

    if (!keepRobotSide) state.robotPlays = other(state.robotPlays);

    snapshot();
    render();
    maybeRobotMove();
  }

  function placeMark(index, mark){
    if (state.board[index] || state.winner) return false;
    state.board[index] = mark;

    const win = computeWinner(state.board);
    if (win) {
      state.winner = win.winner;
      state.winLine = win.line;
      state.isDraw = false;
      vibe([30, 70, 30]);
    } else {
      const empties = getEmptyIndices(state.board);
      state.isDraw = empties.length === 0;
      if (state.isDraw) vibe([10, 50, 10]);
      state.winner = null;
      state.winLine = null;
    }

    state.xIsNext = !state.xIsNext;
    snapshot();
    render();
    return true;
  }

  function handlePlayerMove(index){
    if (state.locked || state.winner) return;

    const current = state.xIsNext ? 'X' : 'O';
    if (state.vsRobot && current === state.robotPlays) return;

    vibe(8);
    if (!placeMark(index, current)) return;
    maybeRobotMove();
  }

  function maybeRobotMove(){
    if (!state.vsRobot || state.winner || state.isDraw) return;

    const current = state.xIsNext ? 'X' : 'O';
    if (current !== state.robotPlays) return;

    state.locked = true; render();

    state.aiTimer = setTimeout(() => {
      state.aiTimer = null;
      const move = chooseRobotMove(state.board, state.robotPlays);
      placeMark(move, state.robotPlays);
      vibe(5);
      state.locked = false; render();
    }, 420 + Math.random()*160);
  }

  function clearAITimer(){
    if (state.aiTimer){ clearTimeout(state.aiTimer); state.aiTimer = null; }
  }

  function undo(){
    clearAITimer();
    state.locked = false;

    let pops = 1;
    if (state.vsRobot){
      const humanMark = state.robotPlays === 'X' ? 'O' : 'X';
      const top = state.history[state.history.length - 1];
      if (top && top.xIsNext === humanMark) pops = 2;
    }
    pops = Math.min(pops, state.history.length - 1);
    if (pops <= 0) return;
    popHistory(pops);
  }

  function restart(){ startNewGame(true); }

  cells.forEach((btn, i) => btn.addEventListener('click', () => handlePlayerMove(i), { passive: true }));
  undoBtn.addEventListener('click', undo);
  restartBtn.addEventListener('click', restart);
  robotToggle.addEventListener('change', (e) => {
    clearAITimer();
    state.vsRobot = !!e.target.checked;
    state.locked = false;
    render();
    if (state.vsRobot) maybeRobotMove();
  });
  levelRadios.forEach(r => {
    r.addEventListener('change', () => {
      if (!r.checked) return;
      state.difficulty = r.value;
      clearAITimer();
      state.locked = false;
      render();
      maybeRobotMove();
    });
  });

  boardEl.addEventListener('keydown', (e) => {
    const idx = cells.indexOf(document.activeElement);
    const row = Math.floor((idx < 0 ? 0 : idx) / 3);
    const col = (idx < 0 ? 0 : idx) % 3;
    const moveFocus = (r,c) => {
      const nr = Math.max(0, Math.min(2, r));
      const nc = Math.max(0, Math.min(2, c));
      const ni = nr*3 + nc;
      cells[ni].focus();
    };

    switch (e.key){
      case 'ArrowUp': e.preventDefault(); moveFocus(row-1, col); break;
      case 'ArrowDown': e.preventDefault(); moveFocus(row+1, col); break;
      case 'ArrowLeft': e.preventDefault(); moveFocus(row, col-1); break;
      case 'ArrowRight': e.preventDefault(); moveFocus(row, col+1); break;
      case 'Enter':
      case ' ':
        e.preventDefault();
        handlePlayerMove(idx >= 0 ? idx : 0);
        break;
      case 'u':
      case 'U':
        e.preventDefault(); undo(); break;
      case 'r':
      case 'R':
        e.preventDefault(); restart(); break;
      case 'c':
      case 'C':
        e.preventDefault(); robotToggle.checked = !robotToggle.checked; robotToggle.dispatchEvent(new Event('change')); break;
    }
  });

  startNewGame(true);
  setTimeout(() => cells[4].focus(), 0);

  // ===== Technology Background Animation (neon network) =====
  const canvas = document.getElementById('techCanvas');
  const ctx = canvas.getContext('2d');
  let W = 0, H = 0, DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  function resizeCanvas(){
    W = canvas.width = Math.floor(window.innerWidth * DPR);
    H = canvas.height = Math.floor(window.innerHeight * DPR);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  const style = getComputedStyle(document.documentElement);
  const c1 = style.getPropertyValue('--accent').trim() || '#9b4dff';
  const c2 = style.getPropertyValue('--accent2').trim() || '#00f5ff';

  // Nodes for network
  const NODES = Math.round(Math.min(70, 35 + window.innerWidth/18));
  const MAX_CONN_DIST = 160; // px in CSS units
  const nodes = [];
  function rand(a,b){ return a + Math.random()*(b-a); }

  for (let i=0;i<NODES;i++){
    nodes.push({
      x: rand(0, W), y: rand(0, H),
      vx: rand(-0.06, 0.06)*DPR, vy: rand(-0.06, 0.06)*DPR,
      r: rand(0.6, 1.6)*DPR
    });
  }

  function step(){
    ctx.clearRect(0,0,W,H);
    ctx.globalCompositeOperation = 'lighter';

    // Draw connections
    const maxDist2 = (MAX_CONN_DIST * DPR) * (MAX_CONN_DIST * DPR);
    for (let i=0;i<nodes.length;i++){
      const a = nodes[i];
      for (let j=i+1;j<nodes.length;j++){
        const b = nodes[j];
        const dx = a.x - b.x, dy = a.y - b.y;
        const d2 = dx*dx + dy*dy;
        if (d2 < maxDist2){
          const t = 1 - (d2 / maxDist2);
          const g = ctx.createLinearGradient(a.x, a.y, b.x, b.y);
          g.addColorStop(0, c1);
          g.addColorStop(1, c2);
          ctx.strokeStyle = g;
          ctx.lineWidth = Math.max(0.6, 2.2 * t);
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
        }
      }
    }

    // Draw nodes
    for (const n of nodes){
      ctx.fillStyle = c2;
      ctx.beginPath();
      ctx.arc(n.x, n.y, n.r, 0, Math.PI*2);
      ctx.fill();

      n.x += n.vx;
      n.y += n.vy;

      if (n.x < -20 || n.x > W+20) n.vx *= -1;
      if (n.y < -20 || n.y > H+20) n.vy *= -1;
    }

    requestAnimationFrame(step);
  }
  step();
})();
</script>
</body>

</html>


